/*
 * PlantControl.c
 *
 *  Created on: Apr 15, 2014
 *      Author: chris
 */


#include "PlantControl.h"
#include "FreeRTOS.h"
#include "timers.h"
#include "math.h"
#include "adc_dac.h"
#include "encoder.h"
#include "RemoteProcPrint.h"
#include "AXI_GPIO.h"


/********************** Global variables for controller **********************/

volatile unsigned sec1000; // This is updated 1000 times per second by interrupt handler
volatile float output_V,theta_R,alpha_R,theta_des;
volatile float thetaDot=0.,alphaDot=0.;
static int printed;
const float Kr2d=180./pi;        //radians to degrees
const float Kpot=-352.*pi/180/10;    //radians/V for pot
const float Kenc=pi/(2.*1024.);     //radians/count for encoder

float u = 0,u1,u2;
volatile float E; // Energy of the pendulum E = (1/2)Jp*alphadort^2 + (1-cos(alpha))*)1/2*mp*Lp*g)

static int k=1; // added for sign of alphadot*cos(alpha) for swing up control
static float thetaOld=0.,alphaOld=0.;

int temp,ind,i,col;
static int enc1, enc2, enc1_start;
volatile float enc1_pr, enc2_pr;
volatile float theta_R_p;
//static float pot1;

float xhat[4];
/*static const float Kf[4][2]={
	{0.9785,0},
	{0,0.9785},
	{0.0109,-0.0251},
	{-0.0278,0.9473}
};*///original
/*static const float Kf[4][2]={
	{0.8527,0},
	{0,0.8529},
	{0.0094,-0.0092},
	{-0.0243,0.8448}
};*///small modification to measurement noise
static const float Kf[4][2]={
	{0.9898,0},
	{0,0.9611},
	{0.0027,-0.0201},
	{-0.0062,0.7778}
};//modification to process noise

static const float Kc[4]={-5.1688,27.7667,-2.7224,3.1787};
/*static const float Aup[4][4]={
    {0.0215,0.000,0.0000,0.0000},
    {0.0000,0.0215,0.0000,0.0000},
    {-0.0109,0.1239,0.9443,-0.0010},
    {0.0278,-0.7977,-0.0535,0.9972}
};*/
/*static const float Aup[4][4]={
    {0.1473,0.000,0.0002,0.0000},
    {0.0000,0.1471,0.0000,0.0002},
    {-0.0094,0.1080,0.9443,-0.0011},
    {0.0243,-0.6952,-0.0535,0.9973}
};*/

static const float Aup[4][4]={
    {0.0102,0.000,0.000,0.0000},
    {0.0000,0.0389,0.0000,0.000},
    {-0.0027,0.1189,0.9443,-0.0010},
    {0.0062,-0.6282,-0.0535,0.9974}
};
//static const float Bup[4]={0,0,0.1013,0.0974};
static const float Bup[4]={0,0,0.1014,0.0971};
static float xpre[4]={0.,0.,0.,0.};
static const float A[4][4] = {
		{1,0.0001,0.0012,0},
		{0,1.0001,-0.0000,0.0012},
		{0,0.0988,0.9443,-0.0011},
		{0,0.1497,-0.0536,0.9984}
};
static const float B[4] = {0.0001,0.0001,0.1013,0.0975};
static const float C[2][4] =  {
		{1,0,0,0},
		{0,1,0,0}
};

static float xdot[4] = {0.,0.,0.,0.};
static float yplant[2] = {0.,0.};
static float del[2] = {0.,0.};
static const eps[2] = {10,10};


// timer callback prototypes
void test_sequence(xTimerHandle pxTimer);
void update_value(xTimerHandle pxTimer);
void swing_up_kalman(xTimerHandle pxTimer);
void predictionTask(void *param);
float calculateKalmanControlSignal(float theta, float alpha);

void startPlantControlTimer(){

	// Write 0 to the motors and initialize the encoder
	initEncoder(ENCODER_S);
	initEncoder(ENCODER_P);

	writeDAC(0);
	theta_des=0.;

	printed = 0;

	// Start a timer with a period of 1ms
	// xTimerHandle ControllerTimerHandle = xTimerCreate((const signed char *)"Controller Timer",(1/portTICK_RATE_MS),pdTRUE,(void *) NULL,update_value);
	xTimerHandle ControllerTimerHandle = xTimerCreate((const signed char *)"Controller Timer",(1/portTICK_RATE_MS),pdTRUE,(void *) NULL,swing_up_kalman);
	//xTimerHandle ControllerTimerHandle = xTimerCreate((const signed char *)"Controller Timer", (1/portTICK_RATE_MS), pdTRUE, (void *) NULL, test_sequence);

	enc1_start = 4;

	xTimerStart(ControllerTimerHandle, portMAX_DELAY);
}


void startPredictionTask(){
	xTaskCreate(predictionTask, (signed char*) "Prediction Task", configMINIMAL_STACK_SIZE,(void *) NULL, prediction_TASK_PRIORITY, ( xTaskHandle * ) NULL );
}


void predictionTask(void *param){

}

void swing_up_kalman(xTimerHandle pxTimer){
	// Timer LED
	setLEDs(LED_7, 1);

	sec1000++;            // Update global variable

	if (enc1_start == 4)	enc1_start = -encoderRead(ENCODER_S)%4096;

	//  code for simple inverted pendulum control -- follows Quanser, no Kalman Filter
	//read positions and compute velocities by filtering
	theta_R_p = readADC()*Kpot;
	//theta_R = theta_R_p;
	temp = -encoderRead(ENCODER_S) % 4096;
	//temp -= enc1_start;
	enc1 = temp;
	enc1_pr = (float)enc1;
	theta_R=temp*Kenc;

	temp = encoderRead(ENCODER_P)%4096;  //force encoder reading to be between 0 and 4096(2pi)
	enc2=temp;
	enc2_pr = (float)enc2;


	if(temp < 0){
		temp += 4096;
	}
	alpha_R = (temp)*Kenc-pi;  //convert to up => alpha=0

	thetaDot = 0.9391*thetaDot+60.92*(theta_R-thetaOld);
	alphaDot = 0.9391*alphaDot+60.92*(alpha_R-alphaOld);
	//need to negate u, so just use positive feedback, u=K*x
	//u=-5.28*(theta_R-theta_des)+30.14*alpha_R-2.65*thetaDot+3.55*alphaDot;

	// self erect control law
	E = (0.00059937)*(alphaDot)*(alphaDot) + (0.2096)*(1-cos(alpha_R)); // calculation of enenrgy of pendulum
	if((cos(alpha_R)*alphaDot)>=0){
		k = 1;
	}else{
		k = -1;
	}
	u2 = 4*(E- 0.42)*k;
	alphaOld = alpha_R;
	thetaOld = theta_R;
	// KALMAN u1 calculated here
	//check to see if we should be controlling.  If not, output 0
	if((alpha_R >= 0 ? alpha_R:-alpha_R) > (30.*pi/180)){
		u2 = 4*(E- 0.42)*k;
		u = u2;
		u1 = 0.;  //if we are not in range do nothing
		writeDAC(u); // use swingup
		writeDAC(0);
		output_V = u1;
		for(ind = 0; ind < 4; ind++){
			xpre[ind] = 0.; //reset estimator
		}

		if(u > 10.){
			u = 10.;
		}else if(u < -10.){
			u = -10.;
		}

	}else{
		//update state estimate based on new input
		for(ind = 0; ind < 4; ind++){
			xhat[ind] = xpre[ind]+Kf[ind][0]*theta_R+Kf[ind][1]*alpha_R;
		}
		//compute control
		u1 = 0.;
		for(ind = 0; ind < 4; ind++){
			u1 += -Kc[ind]*xhat[ind]; // changed the sign for kc to positive
		}
		u1 += Kc[0]*theta_des; // changed the sign of kc to negative
		output_V = -u1;

		//u1=-5.28*(theta_R-theta_des)+30.14*alpha_R-2.65*thetaDot+3.55*alphaDot;

		u = u1;

		// Latancy measuring LED
		setLEDs(LED_6, 1);

		writeDAC(-u);

		++printed; // allow to print


		if(u > 10.){
			u = 10.;
		}else if(u < -10.){
			u = -10.;
		}

		//precompute the part of xhat we can
		for(ind = 0; ind < 4; ind++){
			xpre[ind] = 0.;
			for(col = 0; col < 4; col++){
				xpre[ind] += Aup[ind][col]*xhat[col];
			}
			xpre[ind] += Bup[ind]*u;
		}
		/*if((sec1000%20000)<10000) theta_des=20*pi/180;
	  	  else theta_des=-20*pi/180; */

		theta_des = -90*pi/180;
	}

	// Apply the control input to the plant model*/
	int j; //k,l;
	float tempvec[4];
	for (j = 0; j < 4; ++j)	tempvec[j] = A[j][0]*xhat[0] + A[j][1]*xhat[1] + A[j][2]*xhat[2]+ A[j][3]*xhat[3];
	yplant[0] = tempvec[0]*C[0][0] + tempvec[1]*C[0][1] + tempvec[2]*C[0][2] + tempvec[3]*C[0][3] + C[0][0]*B[0]*u + C[0][1]*B[1]*u + C[0][2]*B[2]*u + C[0][3]*B[3]*u;
	yplant[1] = tempvec[0]*C[1][0] + tempvec[1]*C[1][1] + tempvec[2]*C[1][2] + tempvec[3]*C[1][3] + C[1][0]*B[0]*u + C[1][1]*B[1]*u + C[1][2]*B[2]*u + C[1][3]*B[3]*u;


	/*sendBurstData(unsigned long timestamp, 				float* a, 	float* b, 	float* c,
			float* d, 	float* e, 	float* f, 	float* g, 	float* h, 	float* i,	float* j,
			 float* k, 	float* l, 	float* m, 	float* n, 	float* o, 	float* p)*/

	sendBurstData((xTaskGetTickCount()/portTICK_RATE_MS), 	&theta_R, 	&yplant[0],	&alpha_R,
			&yplant[1],	&u,         &xhat[0], 	&xhat[1], 	&xhat[2], 	&xhat[3],	&enc1,
			&enc2,		&theta_R_p,	&theta_R,	&enc1_pr,	&enc2_pr,		&yplant[0]);


	// Timer LED
	setLEDs(LED_7, 0);
}


float calculateControlSignal(float theta, float alpha){
			for(ind = 0; ind < 4; ind++){
				xhat[ind] = xpre[ind]+Kf[ind][0]*theta_R+Kf[ind][1]*alpha_R;
			}
			//compute control
			u1 = 0.;
			for(ind = 0; ind < 4; ind++){
				u1 += -Kc[ind]*xhat[ind]; // changed the sign for kc to positive
			}
			u1 += Kc[0]*theta_des; // changed the sign of kc to negative
			output_V = -u1;

			//u1=-5.28*(theta_R-theta_des)+30.14*alpha_R-2.65*thetaDot+3.55*alphaDot;

			u = u1;

			// Latancy measuring LED
			setLEDs(LED_6, 1);

			writeDAC(-u);

			++printed; // allow to print


			if(u > 10.){
				u = 10.;
			}else if(u < -10.){
				u = -10.;
			}

			//precompute the part of xhat we can
			for(ind = 0; ind < 4; ind++){
				xpre[ind] = 0.;
				for(col = 0; col < 4; col++){
					xpre[ind] += Aup[ind][col]*xhat[col];
				}
				xpre[ind] += Bup[ind]*u;
			}

}
